#include <stdio.h>
#include <math.h>
int main()
{
    double y;
    int x=130;                          //这是用函数直接计算得出
    y = sqrt(x);
    printf("使用C语言函数计算的结果：\n");
    printf("根号x=%.1f\n",y);     //保留小数点后1位
    printf("根号x=%.2f\n",y);     //保留小数点后2位
    printf("根号x=%.3f\n",y);     //保留小数点后3位
    printf("%.15f\n",y);         //保留到15位小数

    /*接下来使用传统计算：根号114，取离114最近的一个平方数，也就是10的2次方，因为根号114=根号(10的2次方)+14，
     * 有这样一个方程：x=a的2次方+b，那么原式=x-a的2次方=b --> 即(根号x-a)*(根号x+a)=b，所以：
     * 根号x = a + b/(a+根号x)，a是最接近x的平方数，所以a的平方一定小于x，b是x-a的平方的差值，所以a的平方一定大于b，
     * 进行迭代：
     * 根号x = a + b / (a + 根号x) = a + b / (2a + (b / (a + 根号x)))=.....
     * 代入刚才的数字，即：根号114 = 10 + 14 / (2 * 10 + (14 / (10 + 根号114)))，依此类推一直迭代，
     * 然后观察发现，上面式子的"(14 / (10 + 根号114)"的结果远远小于它前面的"2 * 10"的结果，因此，
     * 估算的时候去掉"(14 / (10 + 根号114)"，原式就变成了：根号114 = 10 + 14 / 2 * 10，结果约等于10.7，
     * 随着迭代次数的增加，就可以计算出精度等于迭代层数的结果，
     *如果要取结果的小数点后一位，就取一层迭代，取后两位小数就取两层迭代，接下来用这个方法求根号130的结果，
     * 看一看是不是与C语言提供的函数sqrt计算的结果相同。*/
    int a;
    double b,k;
    printf("使用迭代开方计算的结果 --> ");
    printf("输入最接近计算目标平方数的值：");
    fflush(stdout);
    scanf("%d",&a);
    b = x - a * a;

    k = a + b / (2 * a);        //保留小数点后1位，一层迭代
    printf("根号x=%.1f\n",k);

    k = a + b / (2 * a + (b / (2 * a)));       //保留小数点后2位，二层迭代
    printf("根号x=%.2f\n",k);

    k = a + b / (2 * a + (b / (2 * a + b / (2 * a))));       //保留小数点后3位，三层迭代
    printf("根号x=%.3f\n",k);

    int c;                    //观察规律，迭代可以使用循环实现，由于double精度有效数字只能取到15位，就编写实现保留15位小数的循环
    double d=0;
    c = 2 * a;
    for(int i=0;i<15;i++){
        d = b / (c + d);
    }
    d = d + a;
    printf("%.15f",d);       //保留到15位小数
    return 0;
}
